#!/usr/bin/python

'''
This script uses a sequence-to-structure map to align rate estimates with structural information.

Author: Benjamin R. Jack
'''

import os
import csv
import warnings
import pandas as pd
import argparse
import textwrap

def import_rates(rate_files, seq_count):
    rates = []
    for rate_file in rate_files:
        rates.append(pd.read_csv(rate_file))
        if 'fasta_position' not in rates[-1].keys():
            pass
            # raise KeyError("Column `fasta_position` is missing from rate file '{}'. Without this column, features and rates cannot be aligned.".format(rate_file))
        rate_count = len(rates[-1].index)
        if rate_count != seq_count:
            pass
            # raise RuntimeError(
            #     "The number of positions in the sequence map do not match the number of positions in rate file '{}'.".format(rate_file))
    
    return rates

def import_features(feature_files, seq_count):
    features = []
    for feature_file in feature_files:
        features.append(pd.read_csv(feature_file))
        if not all(k in features[-1] for k in ('pdb_position', 
                                               'pdb_aa', 'chain')):
            raise KeyError(
                "Column `pdb_position`, `pdb_aa`, or `chain` are missing from feature file '{}'. Without these columns, features and rates cannot be aligned.".format(feature_file))
        feature_count = len(features[-1].index)
        if feature_count != seq_count:
            raise RuntimeError(
                "The number of positions in the sequence map do not match the number of positions in feature file '{}'.".format(feature_file))
    
    return features

def align_rates(seq_map, rates):
    for rate in rates:
        rate['fasta_position'] = rate.index + 1
        seq_map = seq_map.set_index('fasta_position').join(rate.set_index('fasta_position')).reset_index()
    
    return seq_map

def main():
    '''
    Align rate estimates with structural information using a 
    sequence-to-structure map.
    '''
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Align rate estimates with structural information using a'
                    'sequence - to - structure map.'
    )
    parser.add_argument('map', metavar='<map>', type=str,
                        help='sequence-to-feature map generated by `make_map.py`')
    parser.add_argument('-r', metavar='<rate files>', type=str,
                        default=None, nargs='*',
                        help='rate files; each file must be a CSV that contains a column `fasta_position`')
    parser.add_argument('-f', metavar='<feature files>', type=str,
                        default=None, nargs='*',
                        help='structural feature files; each file must be a CSV that contains a column `pdb_position`')
    parser.add_argument('-o', metavar='<output prefix>', type=str,
                        help='prefix for output files')
    args = parser.parse_args()
    # Grab PDB name from filename
    pdb_name = os.path.splitext(os.path.basename(args.map))[0]
    # Define output file names
    if args.o is None:
        # If no output prefix given, assign prefix using input filename
        args.o = pdb_name
    output_file = args.o + '.rates_features.csv'

    # Import sequence-to-structure map
    seq_map = pd.read_csv(args.map)
    # Import rates
    rates = import_rates(args.r, seq_map['fasta_position'].count())
    # Join rates to map
    seq_map = align_rates(seq_map, rates)
    
    # Import features
    features = import_features(args.f, seq_map['pdb_position'].count())
    
    pdb_indices = ['pdb_position', 'chain', 'pdb_aa']

    for feature in features:
        seq_map = seq_map.set_index(pdb_indices).join(feature.set_index(pdb_indices)).reset_index()
    
    seq_map.to_csv(output_file, index=False)

if __name__ == "__main__":
    main()
